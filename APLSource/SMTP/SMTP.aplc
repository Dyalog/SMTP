:Class SMTP

⍝ Based on original work by Conrad Hoesle-Kienzlen in 1999
⍝ Updated by Morten Kromberg to use UTF-8 text, 2009
⍝ Updated by Brian Becker in jan2011 to make compatible with Unix and Unicode
⍝ Updated by Brian Becker in mar2019 to use Conga, make it a class, etc
⍝ Updated by Kai Jaeger 2021-08: better traceable & bug fixes & test cases

    (⎕IO ⎕ML)←1

    :Field public Server←''   ⍝ server address
    :Field public Port←⍬      ⍝ server port (default depends on whether running 587 or 465 (secure))
    :Field public From←''     ⍝ default from address for new messages
    :Field public Userid←''   ⍝ userid for authentication (defaults to From)
    :Field public Domain←''   ⍝ fully qualified domain name for EHLO command
    :Field public Org←''      ⍝ optional organization
    :Field public ReplyTo←''  ⍝ optional reply to email address
    :Field public Password←'' ⍝ optional password (if server requires authentication)
    :Field public XMailer←'Dyalog SMTP Client 1.1.0'  ⍝ client identifier
    :Field public Secure←¯1   ⍝ indicates whether to use SSL/TLS, 0 = no, 1 = yes, ¯1 = let port number determine
    :Field public TLSFlags←32 ⍝ by default, accept server certificate without validating (see Conga User Guide Appendix C)
    :Field public CongaRootName←'SMTP'

    :Field public shared CongaRef←''   ⍝ user-supplied reference to location of Conga namespace
    :Field public shared LDRC←''       ⍝ reference to Conga library instance after CongaRef has been resolved

    :Field _clt←''             ⍝ Conga client id
    :Field _loggedOn←0
    :Field _EHLOResponse←''
    :Field _conx←''            ⍝ Conga connection id

    ∇ r←Version
      :Access public shared
      r←'SMTP' '1.4' '2021-08-17'
    ∇

    :Property EHLOResponse
    :Access public
        ∇ r←get
          r←_EHLOResponse
        ∇
    :EndProperty

    :Property Clt  ⍝ client
    :Access public
        ∇ r←get
          r←_clt
        ∇
    :EndProperty

    :Property Conx  ⍝ client connection
    :Access public
        ∇ r←get
          r←_conx
        ∇
    :EndProperty

    :Property LoggedOn  ⍝ has authentication taken place?
    :Access public
        ∇ r←get
          r←_loggedOn
        ∇
    :EndProperty

    :Section Utilities
    if←⍴⍨
    unless←↓⍨
    okay←{0=⊃⍺.(rc msg log)←{3↑⍵,(≢⍵)↓¯99 '' ''},⊆⍵}
    empty←0∘∊⍴
    lc←0∘(819⌶)
    splitOn←{⍵{(≢⍺)↓¨⍵⊂⍨⍺⍷⍵}⍵,⍺} ⍝ e.g. response splitOn CRLF

    ∇ r←Config
    ⍝ returns current service configuration
      :Access public
      r←↑{⍵≡'Password':⍵'********' ⋄ ⍵(⍎⍵)}¨⎕THIS⍎'⎕NL ¯2.2 ¯2.3'
    ∇

    ∇ r←CRLF
      r←⎕UCS 13 10
    ∇


    ∇ (rc msg)←Connected;r;state
      :Access public
      msg←'SMTP server has not been connected'
      →0↓⍨rc←Clt≢''
      :Trap 0 ⍝ handle any Conga error, LDRC not defined, etc
          r←LDRC.Describe Clt
      :Else
          →0⊣(rc msg)←0 'Conga could not query client'
      :EndTrap
      :If 0=⊃r ⍝ good Conga return code?
          :Select state←lc 2⊃3↑2⊃r
          :Case 'client'
              (rc msg)←1 'connected'
          :Case 'error'
              (rc msg)←0 'not connected (possible server timeout)'
          :Else
              (rc msg)←0 'unknown client state: ',∊⍕state
          :EndSelect
      :Else
          (rc msg)←0 'non-zero Conga return code'
      :EndIf
    ∇

    :endsection

    ∇ make
      :Access public
      :Implements constructor
    ∇

    ∇ make1 args
      :Access public
      :Implements constructor
     
      ⍝ args is either a vector with up to 6 elements: [1] server, [2] port, [3] userid, [4] password, [5] from, [6] replyto
      ⍝      or a namespace containing named elements
      :Select ⎕NC⊂'args'
      :Case 2.1 ⍝ variable
          (Server Port From Password Userid ReplyTo Secure)←(Server Port From Password Userid ReplyTo Secure){(≢⍺)↑⍵,(≢⍵)↓⍺},⊆args
      :Case 9.1 ⍝ namespace
          (Server Port From Password Userid ReplyTo Secure)←args{6::⍎⍵ ⋄ ⍺⍎⍵}¨'Server' 'Port' 'From' 'Password' 'Userid' 'ReplyTo' 'Secure'
      :Else
          ⎕←'*** invalid constructor argument'
      :EndSelect
    ∇

    ∇ unmake;base
      :Implements destructor
      :Trap 0
          {}Logoff
          :If 0∊≢⎕INSTANCES base←⊃⊃⎕CLASS ⎕THIS
              base.LDRC←''
          :EndIf
      :EndTrap
    ∇

    ∇ r←NewClient args
      :Access public shared
      r←##.⎕NEW ⎕THIS args
    ∇

    ∇ r←NewMessage args
      :Access public
    ⍝ Create a mew message instance
      r←⎕NEW ##.Message args
      r.Client←⎕THIS
      r.(From XMailer ReplyTo Org)←r.(From XMailer ReplyTo Org){0=≢⍺:⍵ ⋄ ⍺}¨From XMailer ReplyTo Org
    ∇

    ∇ (rc msg log)←Send mail;logIt;message;text;rec
      :Access public
    ⍝ mail is one of:
    ⍝ ∘ an instance of Message
    ⍝ ∘ a namespace with named elements
    ⍝ ∘ a vector of [1] to, [2] subj, [3] body
     
      log←''
      logIt←{⍵⊣log,←⍵[2]}
      (rc msg log)←¯1 '' ''
     
      ⍝ If one of Userid or From is specified, use it for both
      :If 0∊⍴Userid
          Userid←From
      :EndIf
      :If 0∊⍴From
          From←Userid
      :EndIf
     
      →Exit if 0<≢msg←(0∊⍴From)/'No From address specified'
      :If 0=mail.⎕NC'From'
      :OrIf 0=≢mail.From
          mail.From←From
      :EndIf
     
      :Select ⎕NC⊂'mail'
      :Case 9.2 ⍝ instance
          message←mail
      :CaseList 9.1 2.1 ⍝ namespace or vector
          message←NewMessage mail
      :Else
          →Exit⊣msg←'Invalid argument'
      :EndSelect
     
      →Exit if 0≠⊃logIt(rc msg text)←message.Compose
     
      :If ~⊃Connected
          →Exit if 0≠⊃logIt(rc msg)←Connect     ⍝ connect to SMTP server
      :EndIf
     
      :If ~LoggedOn
          →Exit if 0≠⊃logIt(rc msg)←Logon
      :EndIf
     
      →Exit if 0≠⊃logIt(rc msg)←Ping ⍝ ping the server to make sure it's still up
     
      →Err if 0≠⊃logIt(rc msg)←Do'MAIL FROM: ',message.(normalizeAddr extractAddr From)
      :For rec :In message.(normalizeAddr∘extractAddr¨Recipients)
          {}logIt Do'RCPT TO: ',rec
      :EndFor
      →Err if 0≠⊃logIt(rc msg)←Do'DATA'
      →Err if 0≠⊃logIt(rc msg)←Do text,CRLF,'.'
      →Exit
     Err:
      logIt(rc msg)←Do'RSET'
     Exit:
    ∇

    ∇ (rc msg)←{crlf}Xmit data;tmp
      :Access public
    ⍝ transmit data without waiting for a response
    ⍝ {crlf} is a Boolean (default=0) indicating whether to append CRLF to data
    ⍝ After receiving a "DATA" comment, the SMTP server does not send a response until it receives CRLF,'.',CRLF
    ⍝ so, the typical use of Xmit would be to send the headers and content of the message and ending with a Do CRLF,'.'
      :If 0=⎕NC'crlf' ⋄ crlf←0 ⋄ :EndIf
      msg←'Sent'
      →Exit if 0=rc←⊃tmp←LDRC.Send Clt data,crlf/CRLF
      msg←1↓∊' ',¨⍕¨(tmp,'' '')[2 3]
     Exit:
    ∇

    ∇ (rc msg)←Connect;r;uid;dom;cert
      :Access public
      (rc msg)←¯1 ''
      :If 0∊⍴Server
          →Exit⊣msg←'Server not defined'
      :EndIf
     
      :If 0∊⍴Port ⍝ if port not specified, select default based on Secure
          Port←(1+0⌈Secure)⊃587 465
      :ElseIf ¯1=Secure ⍝ else if Secure is not set, set based on Port
          Secure←Port∊465
      :EndIf
     
      Secure←0⌈Secure
      Port←⊃Port
     
      :If ~Port∊⍳65535 ⋄ →Exit⊣msg←'Invalid Port' ⋄ :EndIf
     
      :If 0∊⍴uid←Userid ⋄ uid←From ⋄ :EndIf
      :If 0∊⍴dom←Domain
          dom←##.Message.extractAddr uid
          dom←(⌽∧\'@'≠⌽dom)/dom
      :EndIf
     
      :If 0∊⍴dom ⋄ →Exit⊣msg←'Domain not defined' ⋄ :EndIf
     
      :If 0∊⍴LDRC
      :OrIf {0::1 ⋄ 0≠⊃LDRC.Describe'.'}''
          (rc msg)←Init CongaRootName
      :EndIf
     
      cert←⍬
      :If Secure
          :If 0∊⍴LDRC.X509Cert.LDRC ⋄ LDRC.X509Cert.LDRC←LDRC ⋄ :EndIf
          cert←('X509'(⎕NEW LDRC.X509Cert))('SSLValidation'TLSFlags)
      :EndIf
     
     
      :Select ⊃r←LDRC.Clt(''Server Port'text' 2000000,cert)
      :Case 0
          _clt←2⊃r                   ⍝ Conga client name
          :If 0=⊃(rc msg)←Do''       ⍝ retrieve the server response
              (rc msg)←EHLO dom ⍝ log on user domain
              _EHLOResponse←msg
          :Else
              {}LDRC.Close _clt
              _clt←''
          :EndIf
      :Case 100 ⍝ timeout
          msg←'Conga timeout on connect'
      :Else ⍝ some Conga error occured
          _clt←''
          msg←'Conga error: ',,⍕LDRC.Error⊃r
      :EndSelect
     Exit:
    ∇

    ∇ (rc msg)←EHLO domain;resp;m
      :Access public
    ⍝ Some SMTP servers (gmail in particular) break up the response to EHLO into multiple messages
      :If 0=⊃(rc msg)←Do'EHLO ',domain
          resp←msg splitOn CRLF
          :If '250 '≢4↑⊃⊢/resp  ⍝ this makes the assumption that the EHLO response is in 2 parts only
              :If 0=⊃(rc m)←Do''
                  msg,←m
              :Else
                  msg←m
              :EndIf
          :EndIf
      :EndIf
    ∇

    ∇ (rc msg)←Logon;uid;email;rc;dom;elho;auth
      :Access public
    ⍝ Log on to an SMTP mail server optionally using AUTH LOGIN or AUTH PLAIN authentication if userid and password are non-empty
    ⍝  Other authentication types may be added in the future
    ⍝  If no password is set, then authentication is not done
    ⍝
      (rc msg)←0 'No logon performed, Password is not defined'
      →Exit if 0∊⍴Password
      (rc msg)←¯1 ''
      :If ~⊃Connected
          →Exit if 0≠⊃(rc msg)←Connect
      :EndIf
      elho←' '(,⍨)¨(~EHLOResponse∊CRLF)⊆EHLOResponse
      :If 1≠≢auth←('^250.AUTH '⎕S'%')elho
          →Exit⊣msg←'250-AUTH server response was not found or was not proper'
      :EndIf
      uid←(1+0∊⍴Userid)⊃Userid From
      →Exit if~0∊⍴msg←(0∊⍴uid)/'No Userid or From address specified'
      auth←' '(≠⊆⊢)8↓⊃auth
      :If (⊂'LOGIN')∊auth
          →Exit if 0≠⊃(rc msg)←Do'AUTH LOGIN'
          →Exit if 0≠⊃(rc msg)←Do ##.Message.Base64Encoding uid
          (rc msg)←Do ##.Message.Base64Encoding Password
      :ElseIf (⊂'PLAIN')∊auth
          →Exit if 0≠⊃(rc msg)←Do'AUTH PLAIN'
          (rc msg)←Do ##.Message.Base64Encoding uid,(⎕UCS 0),uid,(⎕UCS 0),Password
      :Else
          'Only authentication methods LOGIN and PLAIN are currently supported'⎕SIGNAL 11
      :EndIf
     Exit:
      _loggedOn←0=rc
    ∇

    ∇ (rc msg)←Logoff
      :Access public
    ⍝ Log out from an SMTP mail server
      :If 0=⊃(rc msg)←Do'QUIT'
          rc←⊃LDRC.Close Clt
      :EndIf
      _loggedOn←0
    ∇

    ∇ (rc msg)←Ping
      :Access public
      (rc msg)←Do'NOOP'
    ∇

    ∇ (rc msg)←Reset
      :Access public
      (rc msg)←Do'RSET'
    ∇

    ∇ r←Do cmd;cnt;rc;c
      :Access public
      →go
    ⍝ Send a command to an smtp server and retrieve answer
    ⍝ cmd: smtp command, or mail body, or empty vector
    ⍝      If cmd is an empty vector, the function returns a pending answer
    ⍝      from the server
    ⍝ r    [1]=0 if OK (response was a 2XX) or 1 if error
    ⍝      [2]=status message starting with a 3-digit status number
    ⍝
    ⍝ Valid commands are:
    ⍝ Name Parameter      Description & return codes (S=success, E=error)
    ⍝ ---- -------------  ------------------------------------------------
    ⍝ HELO <domain>       Make yourself known to the server
    ⍝                      S: 250; E: 421 500 501 504
    ⍝ EHLO <domain>       Like HELO but request extended smtp services
    ⍝                      S: 250; E: 421 500 501 504
    ⍝                      NOTE: apart from code 250, the server answers with
    ⍝                            a cr/lf delimited list of supported commands
    ⍝ MAIL FROM:<sender>  Start a new mail, <sender> is your mail address
    ⍝                      S: 250; E: 421 451 452 500 501 552
    ⍝ RCPT TO:<receiver>  Identify the recipients, up to 100 are allowed
    ⍝                      S: 250 251; E: 421 450 451 452 500 501 503 550-553
    ⍝ DATA                Initialize sending mail body
    ⍝                      S: 354; E: 451 452 552 554
    ⍝ <maildata>          Send the mail body (use smtp_stuff to prepare it)
    ⍝                      NOTE: there is no response until "end-of-mail" is sent.
    ⍝ .<cr/lf>            "end-of-mail" command, a line with only a dot and cr/lf
    ⍝                      S: 250; E: 421 451 500 501 503 554
    ⍝ RSET                Cancel the mail just sent
    ⍝                      S: 250; E: 421 500 501 504
    ⍝ VRFY <string>       Verify a recipients mail address (often disabled)
    ⍝                      S: 250 251; E: 421 500 501 502 504 550 551 553
    ⍝ EXPN <string>       Expand a mailing list (often disabled)
    ⍝                      S: 250; E: 421 500 501 502 504 550
    ⍝ HELP [<string>]     Return a help message, optionally followed by a command
    ⍝                      S: 211 214; E: 421 500 501 502 504
    ⍝ NOOP                Returns success or error
    ⍝                      S: 250; E: 421 500
    ⍝ QUIT                End the smtp session
    ⍝                      S: 221; E: 500
    ⍝ TURN                Reverse the roles of client and server (DON't USE!)
    ⍝                      S: 250; E: 500 502 503
    ⍝
    ⍝ Meaning of the return codes:
    ⍝ NOTE: If the 3-digit number is followed by "-", there is more data to follow
    ⍝ 211 System status, or system help reply
    ⍝ 214 Help message
    ⍝ 220 <domain> Service ready
    ⍝ 221 <domain> Service closing transmission channel
    ⍝ 250 Requested mail action okay, completed
    ⍝ 251 User not local; will forward to <forward-path> (this is not an error!)
    ⍝ 354 Start mail input; end with <CRLF>.<CRLF>
    ⍝ 421 <domain> Service not available, closing transmission channel
    ⍝ 450 Requested mail action not taken: mailbox unavailable [E.g., mailbox busy]
    ⍝ 451 Requested action aborted: local error in processing
    ⍝ 452 Requested action not taken: insufficient system storage
    ⍝ 500 Syntax error, command unrecognized
    ⍝ 501 Syntax error in parameters or arguments
    ⍝ 502 Command not implemented
    ⍝ 503 Bad sequence of commands
    ⍝ 504 Command parameter not implemented
    ⍝ 550 Requested action not taken: mailbox unavailable
    ⍝ 551 User not local; please try <forward-path>
    ⍝ 552 Requested mail action aborted: exceeded storage allocation
    ⍝ 553 Requested action not taken: mailbox name not allowed (typo?)
    ⍝ 555 Only used by this program to indicate a special error condition
     go:
      :If ⊃c←Connected                   ⍝ if we're connected
          :If ~empty cmd
              :If 0≠⊃rc←LDRC.Send Clt(cmd,CRLF)
                  →Exit⊣r←'555 Conga error: ',,⍕2↑rc
              :EndIf
          :EndIf
          cnt←0
     Try:
          :Select ⊃rc←LDRC.Wait Clt 2000  ⍝ wait up to 2 seconds
          :Case 0
              r←¯2↓4⊃rc                     ⍝ grab the data
          :Case 100                         ⍝ timeout, try up to 3 times
              cnt+←1
              →Try if 3>cnt
              r←'555 Conga timeout'
          :Else
              r←'555 Conga error: ',,⍕2↑rc
          :EndSelect
      :Else                              ⍝ if the socket does not exist
          r←'555 SMTP server not connected - ',2⊃c
      :EndIf
     Exit:
      r←((⊃r)∊'45')r                    ⍝ check for error and return
    ∇

    :Section Conga
    ∇ (rc msg)←Init rootname;ref;root;nc;class;dyalog;n;ns;congaCopied
      (rc msg)←¯1 ''
      ⍝↓↓↓ Check is LDRC exists (VALUE ERROR (6) if not), and is LDRC initialized? (NONCE ERROR (16) if not)
      :Hold 'SMTPInit'
          :If {6 16 999::1 ⋄ ''≡LDRC:1 ⋄ 0⊣LDRC.Describe'.'}''
              LDRC←''
              :If 9=#.⎕NC'Conga'
                  {#.Conga.X509Cert.LDRC←''}⍬ ⍝ if #.Conga exists, reset X509Cert.LDRC reference
              :EndIf
              :If ~0∊⍴CongaRef  ⍝ did the user supply a reference to Conga?
                  LDRC←rootname ResolveCongaRef CongaRef
                  :If ''≡LDRC
                      msg←'CongaRef (',(⍕CongaRef),') does not point to a valid instance of Conga'
                      →Exit
                  :EndIf
              :Else
                  :For root :In ##.## #
                      ref nc←root{1↑¨⍵{(×⍵)∘/¨⍺ ⍵}⍺.⎕NC ⍵}ns←(-~0∊⍴rootname)↓'Conga' 'DRC' ⍝ if rootname is supplied, can only use Conga (no DRC)
                      :If 9=⊃⌊nc
                          :Leave
                      :EndIf
                  :EndFor
                  :If 9=⊃⌊nc
                      LDRC←rootname ResolveCongaRef root⍎∊ref
                      :If ''≡LDRC
                          msg←(⍕root),'.',(∊ref),' does not point to a valid instance of Conga'
                          →Exit
                      :EndIf
                      →∆COPY↓⍨{999::0 ⋄ 1⊣LDRC.Describe'.'}'' ⍝ it's possible that Conga was saved in a semi-initialized state
                  :Else
     ∆COPY:
                      class←⊃⊃⎕CLASS ⎕THIS
                      dyalog←{⍵,'/'↓⍨'/\'∊⍨¯1↑⍵}2 ⎕NQ'.' 'GetEnvironment' 'DYALOG'
                      congaCopied←0
                      :For n :In ns
                          :Trap 0
                              n class.⎕CY dyalog,'ws/conga'
                              LDRC←rootname ResolveCongaRef class⍎n
                              :If ''≡LDRC
                                  msg←n,' was copied from [DYALOG]/ws/conga, but is not valid'
                                  →Exit
                              :EndIf
                              congaCopied←1
                              :Leave
                          :EndTrap
                      :EndFor
                      :If ~congaCopied
                          msg←'Neither Conga nor DRC were successfully copied from [DYALOG]/ws/conga'
                          →Exit
                      :EndIf
                  :EndIf
              :EndIf
          :EndIf
          rc←¯1×LDRC≢''
     Exit:
      :EndHold
    ∇

    ∇ LDRC←rootname ResolveCongaRef CongaRef;z;failed
    ⍝ CongaRef could be a charvec, reference to the Conga or DRC namespaces, or reference to an iConga instance
    ⍝ :Access public shared  ⍝!!! testing only  - remove :Access after testing
      LDRC←'' ⋄ failed←0
      :Select ⎕NC⊂'CongaRef' ⍝ what is it?
      :Case 9.1 ⍝ namespace?  e.g. CongaRef←DRC or Conga
     Try:
          :Trap 0
              :If ∨/'.Conga'⍷⍕CongaRef ⍝ is it Conga?
                  LDRC←CongaRef.Init rootname
              :ElseIf 0≡⊃CongaRef.Init'' ⍝ DRC?
                  LDRC←CongaRef
              :Else
                  →0⊣LDRC←''
              :End
          :Else ⍝ if HttpCommand is reloaded and re-executed in rapid succession, Conga initialization may fail, so we try twice
              :If failed
                  →0⊣LDRC←''
              :Else
                  →Try⊣failed←1
              :EndIf
          :EndTrap
      :Case 9.2 ⍝ instance?  e.g. CongaRef←Conga.Init ''
          LDRC←CongaRef ⍝ an instance is already initialized
      :Case 2.1 ⍝ variable?  e.g. CongaRef←'#.Conga'
          :Trap 0
              LDRC←ResolveCongaRef(⍎∊⍕CongaRef)
          :EndTrap
      :EndSelect
    ∇
    :endsection
    
:EndClass
