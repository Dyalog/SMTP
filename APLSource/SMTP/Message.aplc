:Class Message
    :Field public From←''
    :Field public Subj←''
    :Field public ReplyTo←''
    :Field public Org←''
    :Field public To←''           ⍝ vector of email addresses
    :Field public CC←''           ⍝ vector of email addresses
    :Field public BCC←''          ⍝ vector of email addresses
    :Field public Headers←''      ⍝ vector of ('name' 'value')
    :Field public XMailer←''
    :Field public Body←''         ⍝ character vector 'content' or vector of ('MIMEType' 'content')
    :Field public Attachments←''  ⍝ vector of instances of the `Attachment` class.
    :Field public Client          ⍝ reference to SMTP client that created this

    :Field _text←''
    :Field _recipients←''

    :Property Text
    :Access public
        ∇ r←Get
          r←_text
        ∇
    :EndProperty

    :Property Recipients
    :Access public
        ∇ r←Get
          r←_recipients
        ∇
    :EndProperty

    default←{0∊⍴⍺ : ⍵ ⋄ ⍺}

    ∇ make
      :Access public
      :Implements constructor
    ∇

    ∇ make1 args
      :Access public
      :Implements constructor
      :Select ⎕NC⊂'args' ⍝ namespace?
      :Case 9.1
          args{
              0=⍺.⎕NC ⍵:shy←⍬
              ⍎⍵,'←⍺⍎⍵'
          }¨'From' 'Subj' 'ReplyTo' 'Org' 'To' 'CC' 'BCC' 'MIMEType' 'Headers' 'Body' 'Attachments'
      :Case 2.1
          args←,⊆args
          (To Subj Body MIMEType)←4↑args,(≢args)↓'' '' '' ''
      :Else
          'Invalid constructor argument'⎕SIGNAL 11
      :EndSelect
    ∇

    ∇ (rc msg text)←Compose;addHeader;haveAtts;boundary;mime;body;atts;i;n;att;⎕TRAP
      :Access public
        ⍝ Compose email content
      (rc msg text)←¯1 '' ''
      :If 0∊⍴From
          →Exit⊣msg←'"From" is not defined'
      :EndIf
      :If 0∊⍴Subj
          →Exit⊣msg←'"Subj" is not defined'
      :EndIf
      :If (0∊⍴Body)∧0∊⍴Attachments
          →Exit⊣msg←'No body or attachments are defined'
      :EndIf
      MakeRecipients
      :If 0∊⍴Recipients
          →Exit⊣msg←'No recipients are defined'
      :EndIf
     
      addHeader←{
          ⍵∧.=' ':''
          128∧.>⎕UCS ⍵:⍺,': ',⍵,⎕UCS 13 10
          ⍺,': =?utf-8?B?',(Base64Encoding ⍵),'?=',⎕UCS 13 10
      }
     
      text←'Date'addHeader now    ⍝ Internet-conform date first
      text,←'From'addHeader normalizeAddr From  ⍝ the user's name & mail address
      text,←'Reply-To'addHeader normalizeAddr ReplyTo ⍝ the reply-to address
      text,←'Organization'addHeader Org
      text,←'X-Mailer'addHeader XMailer
      text,←'MIME-Version'addHeader'1.0'
      text,←∊CRLF∘(,⍨)¨('B'≠⊃¨Recipients)/Recipients ⍝ no headers for BCC recipients
      text,←'Subject'addHeader Subj ⍝ the message subject
     
      :If haveAtts←~0∊⍴Attachments ⍝ Any attachments?
          boundary←'000',((⍕⎕TS)~' '),'DyalogSMTP',CRLF ⍝ construct a boundary for attachments
          text,←'Content-Type'addHeader'multipart/mixed; boundary="',(¯2↓boundary),'"'
          text,←CRLF
          text,←'This is a multi-part message in MIME format.',CRLF
          text,←'--',boundary
      :EndIf
     
      :If 0≠≢Body
          (mime body)←¯2↑'' '',⊆Body
          :If Body beginsWith'file://'
              body←⊃⎕NGET 7↓Body
          :EndIf
          :If 0∊⍴mime
              mime←(1+'<html'≡0(819⌶)5↑body)⊃'plain' 'html'
              mime←'text/',mime,'; charset="UTF-8"'
          :EndIf
          text,←'Content-Type'addHeader mime
          text,←CRLF
          text,←⎕UCS'UTF-8'⎕UCS body
          text,←CRLF
      :EndIf
     
      :If haveAtts
          text,←haveAtts/'--',boundary
     
          Attachments←FormatAttachments Attachments
     
          :For i :In ⍳n←≢Attachments
              :If 0∊⍴att←i ProcessAttachment i⊃,Attachments
                  msg←'Error processing attachment ',(⍕i),', file="',(1⊃i⊃Attachments),'"'
                  →Exit
              :EndIf
              text,←att
              text,←'--',boundary
              :If i=n ⍝ last attachment?
⍝                      text←(¯2↓text),'--',CRLF,CRLF
              :EndIf
          :EndFor
      :EndIf
      (rc msg)←0 ''
     Exit:
    ∇

    ∇ Attach attachment
      :Access public
      Attachments←(FormatAttachments⍣(~0∊⍴Attachments)⊢Attachments),FormatAttachments attachment
    ∇

    ∇ atts←FormatAttachments atts
      :Access public shared
      :Select |≡atts
      :CaseList 0 1  ⍝ filename
          atts←,⊂(⊂,atts),'' ''
      :Case 2   ⍝ filename mimetype
          atts←,⊂atts
      :Case 3   ⍝ filename mimetype content
      :EndSelect
    ∇

    ∇ r←Send
      :Access public
      r←Client.Send ⎕THIS
    ∇

    ∇ r←i ProcessAttachment arg;mime;content;file;name;⎕TRAP
      (file mime content)←3↑(⊆arg),'' '' ''
      :If 0∊⍴file
          name←'Attachment-',(⍕i),,'<->,4ZI2,<.>,ZI3'⎕FMT 1 5⍴2↓⎕TS  ⍝ make an arbitrary one
      :Else
          name←∊¯2↑⎕NPARTS file←(7×'file://'≡7↑file)↓file
          :If 0∊⍴content ⍝ attempt to read content
              content←ReadFile file
          :EndIf
      :EndIf
      r←''
      :If 0≠≢content
          :If 0∊⍴mime
              mime←'application/octet-stream'
          :EndIf
          r←'Content-Type: ',mime,'; charset="US-ASCII"; name="',name,'"',CRLF
          r,←'Content-Disposition: attachment; filename="',name,'"',CRLF
          r,←'Content-Transfer-Encoding: base64',CRLF,CRLF
          r,←chunk Base64Encoding content
      :EndIf
    ∇

    ∇ r←ReadFile file;tno
        ⍝ We don't trap errors here because we don't want to pretend to send emails with attachments when we might not
      tno←file ⎕NTIE 0
      r←⎕NREAD tno,(⎕DR' '),¯1 0
      ⎕NUNTIE tno
    ∇

    ∇ MakeRecipients;addrs
      :Access public
      _recipients←''
      _recipients,←'To'FormatList To
      _recipients,←'CC'FormatList CC
      _recipients,←'BCC'FormatList BCC
    ∇

    ∇ list←type FormatList list
      :If ~0∊⍴list
          :If 2=≢⍴list ⍝ matrix of names?
              list←↓list
          :Else
              list←list((~∊)⊆⊣)',;' ⍝ otherwise split on ; or ,
          :EndIf
          list←{⍵↓⍨-+/∧\' '=⌽⍵}¨list
          list←(type,': ')∘,¨normalizeAddr¨list
      :EndIf
    ∇

    ∇ r←CRLF
      :Access public shared
      r←⎕UCS 13 10
    ∇

    ∇ r←{len}chunk content;breaks;mask;stuff
      :Access public shared
        ⍝ Convert content into a vector with embedded cr/lf plus dot-stuffing
        ⍝ len : the maximum line length, excluding cr/lf line ends. Defaults to 72,
        ⍝       as 74 is a safe line length to transmit through SMTP
        ⍝ rc  : A string with cr/lf every len characters and dot-stuffing
        ⍝ NOTE: It is safe to send a Base64-encoded string through this function,
        ⍝       as those strings do not contain any dots. However, the function does
        ⍝       not work well if there are cr/lf already present in the input.
        ⍝ Dot-Stuffing: The end of an SMTP mail text is indicated by transmitting
        ⍝               a line with a single dot. This means, that the original
        ⍝               mail text must not contain a single dot on a line by itself.
        ⍝               To prevent this, every line that starts with a dot get's
        ⍝               preceeded with a second dot, which will be removed by the
        ⍝               recipients mail client. See pop3_unstuff, the reverse function.
     
      stuff←{'.'=⊃⍵:'.',⍵ ⋄ ⍵}
     
      :If 900⌶⍬ ⋄ len←72 ⋄ :EndIf    ⍝ default line length, if not given
      :If 2>|≡content ⍝ simple array? otherwise, treat it as a vector of vectors
          :Select ≢⍴content
          :Case 0
              content←,⊂,content
          :Case 1
              :If ∨/CRLF∊content         ⍝ any line breaks?
                  content,⍨←CRLF
                  breaks←CRLF∘.=content
                  content←(~∘⊂CRLF)¨content⊂⍨(∨⌿breaks)≠breaks[2;]∧¯1↓0,breaks[1;] ⍝ break on CRLF or lone CR or lone LF
              :Else
                  content←,⊂content
              :EndIf
          :Case 2
              content←↓content
          :Else
              content←↓((×/¯1↓⍴content),¯1↑⍴content)⍴content
          :EndSelect
      :EndIf
     
      content←{⍵↓⍨-⊥⍨' '=⍵}¨content ⍝ delete trailing blanks
      content←stuff¨content ⍝ dot-stuff (double leading dot)
     
      :If ∨/mask←len<≢¨content  ⍝ any lines longer than length?
          :If 1=≢content ⍝ single chunk
              content←{((≢⍵)⍴len↑1)⊂⍵}⊃content
              (1↓content)←stuff¨1↓content
          :Else
              content←({⊂len∘chunk ⍵}@{mask})content
          :EndIf
      :EndIf
      r←∊content,¨⊂CRLF
    ∇

    ∇ r←extractAddr addr;quotes;ind;del
      :Access public shared
        ⍝ extract the mail address from a string
        ⍝ perform very cursory validation on the address
        ⍝ addr - the string to be validated (can be in form "Fred Bloggs" fred@bloggs.com)
        ⍝ r    - the email address or empty if not valid
      r←''
      quotes←(⊢∨≠\)'"'=addr ⍝ mask out quoted material e.g. "fred@work" fred@bloggs.com
      ind←⊃⍸quotes<addr='@'
      :If ind≠0
          del←0,(1+≢addr),⍨⍸quotes<' '=addr ⍝ break on space
          r←addr{⍵[1]↓(¯1+⍵[2])↑⍺}del[0 1+del⍸ind]
          r←⊃('.+@[^.].+\..+'⎕S'%')r
      :EndIf
    ∇

    ∇ addr←normalizeAddr addr;a
      :Access public shared
      :If 0<≢addr~' '  ⍝ MB: avoid issues when addr is a 0/ManyAddrs
          :If '<>'≢(⊣/,⊢/)a←extractAddr addr
              addr←(addr/⍨~∨\⌽<\⌽a⍷addr),'<',a,'>'
          :EndIf
      :EndIf
    ∇

    ∇ r←Base64Encoding txt;⎕IO;A;ed
        ⍝ ⍵ byte string: 256∧.>⎕ucs ⍵
        ⍝ ← longer (4:3) string in A-Z,a-z,0-9,+/= only
      :Access public shared
      ⎕IO←0
      A←'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
      ed←{⊃⍵{⍺{2⊥⍉((⌈(⍴⍵)÷⍺),⍺){⍺⍴(×/⍺)↑⍵}⍵},⍉(⍵⍴2)⊤⍺⍺}/⍺}
      r←{⍵,'='⍴⍨4|-⍴⍵}(⊂6 8 ed ⎕UCS txt)⌷A
    ∇

    ∇ rc←now;time;day;mon;s;x;LOCTIME;TIMEZONE;isUnicode;twid
      :Access public shared
        ⍝ returns an internet-conforming (RFC 2822) timestamp
      :If 'Win'≡3↑⊃'.'⎕WG'APLVersion'
          isUnicode←80=⎕DR'A'
          twid←64 32[1+isUnicode] ⍝ set width for text elements based on unicode or not
          'LOCTIME'⎕NA'KERNEL32.C32|GetLocalTime >{I2[8]}' ⍝ associate GetLocalTime function
          'TIMEZONE'⎕NA'U4 KERNEL32.C32|GetTimeZoneInformation >{I4 T[',(⍕twid),'] {I2[8]} I4 T[',(⍕twid),'] {I2[8]} I4}' ⍝ associate GetTimeZone function
        ⍝ prepare values for time formatting
          day←'Sun,' 'Mon,' 'Tue,' 'Wed,' 'Thu,' 'Fri,' 'Sat,'
          mon←'Jan ' 'Feb ' 'Mar ' 'Apr ' 'May ' 'Jun ' 'Jul ' 'Aug ' 'Sep ' 'Oct ' 'Nov ' 'Dec '
        ⍝ read the local time and format to Internet standard
          time←⊃LOCTIME⊂8⍴1000
          rc←(1+time[3])⊃day
          rc←rc,,'< >,ZI2,< >'⎕FMT time[4]
          rc←rc,time[2]⊃mon
          rc←rc,,'I4,< >,ZI2,<:>,ZI2,<:>,ZI2,< >'⎕FMT 1 4⍴time[1 5 6 7]
        ⍝ call timezone function and calculate offset from GMT
          x←TIMEZONE⊂0(twid⍴' ')(8⍴0)0(twid⍴' ')(8⍴0)0
          x←(⊃x),2⊃x
          s←'+-'[1+0>x←(-2⊃x)+-x[(5 8)[⊃x]]]
          rc←rc,s,,'ZI4,< (GMT)>'⎕FMT|100×x÷60
      :Else
          rc←1⊃⎕SH'date -R' ⍝ unix - call date command
      :EndIf
    ∇

    ∇ r←Config
        ⍝ returns current message configuration
      :Access public
      r←↑{⍵(⍎⍵)}¨⎕THIS⍎'⎕NL ¯2.2 ¯2.3'
    ∇

    beginsWith←{⍵≡(≢⍵)↑⍺}
:EndClass
